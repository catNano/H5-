

## 事件

#### 事件侦听和删除侦听

事件：通知和侦听组合完成的，先侦听后通知，执行对应的函数

创建一个事件对象

- 事件类型必须是一个字符串
- 部分事件是系统默认事件，这些事件会由系统自动抛发

```
var evt = new Event("天王盖地虎");
document.dispatchEvent(evt);//通知，抛发
```

##### 侦听事件

**IE9以上**

```
document.addEventListener("天王盖地虎",eventHandler);
function eventHandler(e){
    console.log(e);
}
```

1. 事件的类型必须相同
2. 事件侦听的对象和抛发的对象必须相同
3. 将事件抛向侦听对象就可以
4. 先侦听，后抛发
5. 事件对象.addEventListener(事件类型，事件回调函数，是否是捕获阶段（默认false，即冒泡阶段）);
6. 事件对象  必须是EventTarget或者继承他所产生子类

```
var obj={
    n:1,
    a:function(){
        document.addEventListener("chilema",this.b);
        var evt=new Event("elema");
        evt.n=this.n;
        document.dispatchEvent(evt);
    },
    b:function(e){
      console.log(e.s);
    }
}

var obj1={
    c:function(){
        document.addEventListener("elema",this.d);
    },
    d:function(e){
      console.log(e.n);
      var s=e.n;
      s++;
      var evt=new Event("chilema");
      evt.s=s;
      document.dispatchEvent(evt);
    }
}


obj1.c();
obj.a();
```

**ie8及以下**

​	element.attachEvent(‘on开头的事件名’,事件函数名)

##### 删除侦听

**IE9以上**

removeEventListener(事件类型，事件回调函数，{once:true}(监听一次));

```
var div=document.getElementsByTagName("div")[0];
// 事件类型，事件回调函数,(是否捕获时触发)
div.addEventListener("click",clickHandler);


function clickHandler(e){
    console.log(e);
    // 删除事件侦听(事件类型,删除事件侦听的回调函数)
    // this.removeEventListener("click",clickHandler)
    this.removeEventListener("click",arguments.callee);
}
```

**ie8及以下**

detachEvent(‘on开头的事件名’,事件函数名)

##### 事件侦听和删除的兼容写法

**增加侦听**

```
function addEventListen(elem,type,callback){
    try{
        elem.addEventListener(type,callback)
    }catch(e){
        elem.attachEvent("on"+type,callback);
    }
}
```

**删除侦听**

```
function removeEventListen(elem,type,callback){
    try{
        elem.removeEventListener(type,callback)
    }catch(e){
        elem.detachEvent("on"+type,callback);
    }
}
```

##### 三种侦听的区别

- addEventListener

  缺点：不支持IE8及以下，方法名太长

  优点：支持捕获和冒泡阶段分开侦听

  ​			支持事件抛发机制

  ​			支持同一个事件做多个事件回调函数

  ​			事件使用时可以将函数与内容完全分离

- attachEvent

  缺点：IE8以上不支持，没有捕获，不支持一次点击，未来被淘汰

  优点：支持IE8以下，并且可以使一个事件调用多个回调函数

  ​			事件使用时可以将函数与内容完全分离

- onclick=fn

  缺点：不支持事件抛发，只能使用系统默认事件

  优点：全浏览器支持，不考虑兼容问题

  ​			代码便捷

  ​			不支持同一个事件做多个事件回调函数

  ​			因为代码大量使用匿名函数，容易造成回调地狱，并且在开发中，代码和代码的实际功能不能分离

  ```
  div.onclick=function(){
      console.log("a");
      div.onclick=null;//删除事件
  }
  ```

  

#### 事件原理

##### 捕获阶段

从外向里

##### 目标阶段

最后点击到的叫目标

##### 冒泡阶段

从里向外

【注】

- e.stopPropagation();	停止冒泡
- e.cancelBubble=true;    IE兼容事件，取消冒泡

```
div0.addEventListener("click",div0ClickHandler);
div1.addEventListener("click",div1ClickHandler,true);
div2.addEventListener("click",div2ClickHandler);

function div0ClickHandler(e){
	e.cancelBubble=true;//IE兼容事件，取消冒泡
    console.log("div0");
}

function div1ClickHandler(e){
    console.log("div1");
    e.stopPropagation();//停止冒泡
}

function div2ClickHandler(e){
    console.log("div2");
}
```

- e.currentTarget--->事件侦听的对象---->this
- e.target--->e.srcElement--->e.toElement  事件点击的目标对象
- 事件委托：将子元素事件委托给父元素，这样就可以减少侦听的数量

```
<ul id="menu">
    <li>北京
        <ul>
            <li>昌平
                <ul>
                    <li>回龙观</li>
                    <li>天通苑</li>
                    <li>沙河</li>
                    <li>霍营</li>
                    <li>老牛湾</li>
                </ul>
            </li>
            <li>海淀</li>
            <li>朝阳</li>
            <li>东城</li>
        </ul>
    </li>
    <li>山西</li>
    <li>陕西
        <ul>
            <li>西安</li>
            <li>咸阳
                <ul>
                    <li>三原</li>
                    <li>礼泉</li>
                    <li>乾县</li>
                    <li>淳华</li>
                    <li>旬邑</li>
                </ul>
            </li>
            <li>宝鸡</li>
            <li>安康</li>
            <li>延安</li>
        </ul>
    </li>
    <li>河北</li>
    <li>河南</li>
</ul>

init();
function init(){
    var ul=document.querySelector("#menu");
    ul.addEventListener("click",clickHandler);
}

function clickHandler(e){
    // if(e.target.nodeName!=="LI")return;
    if(e.target.constructor!==HTMLLIElement)return;
    e.target.bool=!e.target.bool;		//原理没有bool，是undefined，取反，则是true
    if(!e.target.firstElementChild)return;
    if(e.target.bool)e.target.firstElementChild.style.display="none";
    else e.target.firstElementChild.style.display="block";
}
```

#### 事件对象

1. e.type  事件类型  click
2. e.target e.srcElement   事件目标对象
3. e.currentTarget  this   事件侦听对象
4. e.cancalBubble   设置取消冒泡

```
var div=document.querySelector("div");
div.addEventListener("click",clickHandler);

function clickHandler(e){
    console.log(e);	//e则是系统传入的事件对象 
}
```

#### Event事件

change	只能针对表单触发

- input  如果input.value值发生改变，并且失去焦距触发
- input checkbox radio可触发

```
<input type="text" id="user">

var user=document.querySelector("#user");
user.addEventListener("change",changeHandler);
function changeHandler(e){
    console.log(user.value);
}
```

- select select.value是选中的值

- 如果增加多选  multiple

  select.selectedOptions  被选择多个元素   select.selectedOptions[i].textContent

  select.selectedIndex   选择下标
  
  

```
<select multiple>
    <option>北京</option>
    <option>西安</option>
    <option>武汉</option>
    <option>天津</option>
    <option>青岛</option>
</select>

var user=document.querySelector("select");
user.addEventListener("change",changeHandler);
function changeHandler(e){
	console.log(user.value);
}
```

load	error

- load 和error 用于图片的加载，Ajax通信以及JSON或者其他文件的加载等

  load是加载成功，error是加载错误事件

- 图片加载是需要事件的

- 任何内容没有放在页面中，不能调用clientWidth,offsetWidth,scrollWidth这样的数据

```
var img=new Image();//document.createElement("img");
img.addEventListener("load",loadHandler);
img.src="./img/6-.jpg";
document.body.appendChild(img);
// console.log(img.offsetWidth); //如果没有load事件，img.offsetWidth为0

function loadHandler(e){
    console.log("aaa");
    console.log(img.offsetWidth)
}
```

- load还可以用于window加载创建完成
- 使用window，侦听load事件
  1. 所有的DOM加载完成
  2. 所有的图片已经加载完成

```
window.addEventListener("load",loadHandler);

function loadHandler(e){
    console.log(e);
    var div1=document.getElementById("div1");
     console.log(div1);	
     //如果div标签放在此script之后，用load可以加载成功
}
```

reset	submit

- submit和reset只能针对form表单侦听，不能针对input
- 提交和重置时收到事件

```
<form action="http://www.163.com" method="GET">
    <input type="text" name="user">
    <input type="password" name="password">
    <input type="submit">
    <input type="reset">
</form>

var form=document.querySelector("form");
form.addEventListener("submit",submitHandler);
form.addEventListener("reset",submitHandler);

function submitHandler(e){
    // 阻止默认事件
    e.preventDefault();
    // e.returnValue=false  兼容写法
    console.log(e);
}
```

resize	针对window和textArea的事件

```
window.addEventListener("resize",resizeHandler);

function resizeHandler(e){
    console.log(document.documentElement.clientWidth)
}
```

- em  这个是当前元素相对父容器font-size的大小
- rem  相对根元素font-size的大小

应用：页面跟着窗口收缩

```
div
{
    width: 1rem;
    height: 1rem;
    background-color: red;
}
img{
    width: 5.12rem;
    height: 3.11rem;
}

<div></div>
<img src="./img/6-.jpg">

window.addEventListener("resize",resizeHandler);
function resizeHandler(e){
    document.documentElement.style.fontSize=document.documentElement.clientWidth*(100/screen.width)+"px";
}
```

select	针对input的事件

- input文本选择文字时触发

```
<input type="text">

var input=document.querySelector("input");
input.addEventListener("select",selectHandler);

function selectHandler(e){
    //console.log("aa");
    //console.log(input.selectionStart);
    //console.log(input.selectionEnd);
input.value=input.value.slice(0,input.selectionStart)+input.value.slice(input.selectionEnd);
}
```

unload	卸载 现在不用了

scroll

```
div{
    width:50px;
    height: 50px;
    overflow: scroll;
}

var div=document.querySelector("div");
div.addEventListener("scroll",scrollHandler);

function scrollHandler(e){
    console.log(div.scrollTop)
}
```

popstate

- PopStateEvent   popstate事件 历史记录被回退和前进时触发

```
document.addEventListener("click",clickHandler);
window.addEventListener("popstate",popstateHandler);
function clickHandler(e){
    history.pushState({a:1},"","#1");
}

function popstateHandler(e){
    console.log(e);
}
```

#### 鼠标事件

click	点击左键

```
<div class="div0"></div>

var div=document.querySelector(".div0");
div.addEventListener("click",clickHandler);

function clickHandler(e){
    console.log(e);
    console.log(e.clientX,e.clientY);
}
```

```
//鼠标距离可视区域左上角
clientX: 33
clientY: 31

//如果目标对象是定位方式，值与offset相似
//如果目标对象是非定位方式，值取父容器的左上角位置，如果父容器未定位，继续向上取
layerX: 28
layerY: 20

//鼠标相对事件目标对象左上角位置
offsetX: 16
offsetY: 9

//仅用于mousemove事件 这个值是鼠标移动时相对上次获取坐标的位置距离
movementX: 0
movementY: 0

//相对页面顶端左上角位置
pageX: 28
pageY: 25

//相对页面屏幕左上角位置
screenX: 38
screenY: 107

//和clientX，clientY相同
x: 32
y: 33

//按下键点击出鼠标时变为true
altKey: false
ctrlKey: false
metaKey: false
shiftKey: false

//针对mousedown事件的属性，判断按下的键
		左键	中键	右键
button:  0	  0		2
buttons: 0	  4		2
which:   1	  2		3
```

dblclick	双击左键

mousedown	按下键

mouseup	释放键

【注】先down，然后up，click

mouseover	滑过

mouseout	滑出

mouseenter	进入

mouseleave	离开

【注】over，out具有冒泡的功能，可以收到滑入滑出子元素的冒泡事件

​			enter，leave仅对侦听的对象起到事件接受作用

mousemove	移动

contextmenu	右键菜单

#### 取消默认事件

1. 表单事件中的submit reset 使用阻止默认事件可以取消提交和重置

   ```
   var form=document.querySelector("form");
   form.addEventListener("submit",formHandler);
   form.addEventListener("reset",formHandler);
   
   function formHandler(e){
       e.preventDefault();
   }
   ```

2. 当使用contextmenu事件，取消鼠标右键菜单

   ```
   document.addEventListener("contextmenu",mouseHandler);
   function mouseHandler(e){
       e.preventDefault();
   }
   ```

3. 当针对元素拖拽时，元素内有文本，文本会被选中

   ```
   var div=document.querySelector("div");
   div.addEventListener("mousedown",mouseHandler);
   
   function mouseHandler(e){
       e.preventDefault();
   }
   ```

4. 图片拖拽时产生禁止拖拽图标

   ```
   var img=document.querySelector("img");
   img.addEventListener("mousedown",mouseHandler);
   
   function mouseHandler(e){
       e.preventDefault();
   }
   ```

#### 焦距和input事件

##### FocusEvent	焦距事件

focus	汇聚焦距

blur	失去焦距

适用事件：所有的表单元素，例如文本框、超链接

触发条件：focus汇聚焦距的方式有点击，tab切换

```
var input0=document.querySelector("#input0");
var input1=document.querySelector("#input1");
input0.addEventListener("focus",focusHandler);
input1.addEventListener("focus",focusHandler);

function focusHandler(e){
    console.log(e);
    // e.relatedTarget  上次汇聚焦距的元素
}
```

##### inputEvent	input事件


​    e.data: "XXXX"  输入的内容

​    e.inputType: "insertText" 输入的类型  insertCompositionText
​                 包括插入文本，删除文本，插入输入法文本，剪切粘贴文本等等

​    e.isComposing: true   是否是输入法文本   

```
var input0=document.querySelector("#input0");
input0.addEventListener("input",inputHandler);

function inputHandler(e){
    console.log(e);
    if(!isNaN(e.data)) input0.value=input0.value.replace(e.data,"");
}
```

节流

```
var input0=document.querySelector("#input0");
var ids;
input0.addEventListener("input",inputHandler);

function inputHandler(e){
    if(ids!==undefined) return;
    ids=setTimeout(function(){
        clearTimeout(ids);
        ids=undefined;
        console.log(input0.value);
    },500);
}
```

防抖

在设置setInterval定时器时，利用下面代码可以让抖动减少

```
time--;
if(time>0)return;
time=15;
```

#### 按键事件

```
e.code: "KeyA"
e.key: "a"
e.keyCode: 65
e.which: 65
```

keydown

keyup

keypress

```
<style>
    textarea
    {
        width: 800px;
        height: 400px;
    }
    input
    {
        width: 600px;
    }
    div
    {
        width: 500px;
        height: 400px;
        border:1px solid #000000;
        word-wrap: break-word;
    }
</style>

<textarea id="texts"></textarea><br>
<input type="text" id="msg">
<button>提交</button>

var texts,msg,bn
init();
function init(){
    texts=document.querySelector("#texts");
    msg=document.querySelector("#msg");
    bn=document.querySelector("button");
    bn.addEventListener("click",clickHandler);
    document.addEventListener("keydown",clickHandler);
}

function clickHandler(e){
    if(e.type!=="click" && e.type!=="keydown") return;
    if(e.keyCode && e.keyCode!==13) return;
    if(msg.value.trim().length<1) return;
    texts.value+=msg.value+"\n";
    msg.value="";
}
```

```
//富文本编辑器
var div=document.querySelector("div");
document.addEventListener("keydown",keyHandler);
// document.addEventListener("keyup",keyHandler);

function keyHandler(e){
    if(e.keyCode<48 || e.keyCode>57 && e.keyCode<65 || e.keyCode>90) return;
    div.innerHTML+=e.key;
}
```

#### WheelEvent事件

```
window.addEventListener("mousewheel",wheelHandler);
//火狐浏览器
window.addEventListener("DOMMouseScroll",wheelHandler);


function wheelHandler(e){
    if(e.type==="mousewheel"){
        speed=e.deltaY<0 ? -10 : 10; 
    }else if(e.type==="DOMMouseScroll"){
        speed=e.detail<0 ? -10 : 10;
    }
}
```

google和IE

```
向上

//google
deltaX: -0
deltaY: -100	//固定值
deltaZ: 0
detail: 0
wheelDelta: 120	//固定值
wheelDeltaX: 0
wheelDeltaY: 120

//火狐
e.detail: -3
```

#### 案例：拖拽

**this**
1、在函数中this等于window
2、对象自身this等于obj
3、在事件函数中this等于事件侦听对象，

【注】

- 事件函数者中的this会覆盖普通对象中函数this的指向
- 事件函数中，针对e.type事件类型所有对应的事件侦听对象才是this

**拖拽方法**

拖拽元素
参数:
elem：被拖拽的HTML标签DOM元素  HTMLElement
parentOut:是否不允许拖拽到容器外
  类型 Boolean：true 不允许拖拽到父容器外
               				false 允许拖拽到父容器外
      	Object 示例：{width:Number,height:Number};
            				width和height限制拖拽的范围
            				如果为0，该方向不能拖拽
返回：无

```
1、完成拖拽的起始侦听事件，当侦听在元素上按下mousedown事件时执行当前对象的函数mousedownHandler
2、将当前对象存储在这个元素的obj属性中，用于在后面按下时调用到当前对象
3、设置这个元素的定位为绝对定位
4、设置document对象的属性是当前带入参数是否不允许拖拽到容器外这个值，用来在后续中判断该元素是否允许拖拽脱离当前容器

dragElem:function(elem,parentOut){
    elem.obj=this;	//此时的this是Utils，存储在elem的obj属性中
    elem.style.position="absolute";	//给元素添加定位，脱离文档流
    document.parentOut=parentOut;	//将parentOut存储在document的parentOut属性中
    elem.addEventListener("mousedown",this.mousedownHandler);
},
```

```
鼠标按下键和鼠标移动，释放的事件函数
参数：
    e  MouseEvent 鼠标对象 由鼠标事件自动创建该参数
1、鼠标按下时
    鼠标按下时 this,e.currentTarget   针对标签元素  this->按下的标签元素
      1、取消默认事件行为，可以解决拖拽时产生禁止拖拽图标
      2、将当前按下鼠标左键相对元素左上角的坐标存储在document的对象属性X和y上
        用于后面调用时使用
     3、将当前this，也就是按下的元素存储在document对象属性div中
     4、将当前Utils这个对象存在document对象属性obj中，用于后面的调用
    5、针对document侦听鼠标移动和释放事件，执行的函数是Utils对象，这个对象存在this.obj
        也就是按下元素的obj属性
2、鼠标移动时
    this，因为鼠标是侦听document上移动的事件，所以，this是document
    1、获取当前按下元素的父元素，this.div就是document.div,这个在按下时做了存储
      并且求出它的父元素的范围矩形，这个返回矩形包括父元素的相对可视窗口的坐标和父元素宽高
    2、计算出x，y是当前鼠标移动位置相对当前元素父元素的左上角位置 
    3、判断 parentOut传入参数属性是不是允许拖拽到父元素外，如果是true，不允许拖拽到父元素外
        如果是对象就需要设置拖拽的范围
        如果是true，拖拽时禁止x和y小于0，限制右侧和下侧不出容器
        如果时对象，限制不出对象宽高的范围，
    4、设置这个元素的位置是调整过后坐标
3、鼠标释放时
   删除document上所有的mousemove事件和mouseup事件
   
mousedownHandler:function(e){
    if(e.type==="mousedown"){
        e.preventDefault();
        document.x=e.offsetX;   //鼠标据拖拽的元素左上角的距离
        document.y=e.offsetY;
        document.elem=this; //此时的this是拖拽的元素，存储在document的属性中
        document.obj=this.obj;  //将上个方法存储在elem中的utils存储在document中
        document.addEventListener("mousemove",this.obj.mousedownHandler)
        document.addEventListener("mouseup",this.obj.mousedownHandler)
    }else if(e.type==="mousemove"){
        var rect=this.elem.parentElement.getBoundingClientRect();
        //this是document，getBoundingClientRect获取elem父元素到可视窗口的距离
        var x=e.clientX-this.x-rect.x;
        var y=e.clientY-this.y-rect.y;
        //元素据父元素的距离=鼠标据可视窗口的距离-鼠标据拖拽的元素左上角的距离-父元素到可视窗口的距离
        if(this.parentOut===true){
        //true为不允许拖拽到父元素外面
            if(x<0) x=0;
            if(x>=rect.width-this.elem.offsetWidth)x=rect.width-this.elem.offsetWidth;
            //父元素的宽度（width+padding+border）-子元素的宽度（width+padding+border）
            if(y<0) y=0;
            if(y>=rect.height-this.elem.offsetHeight) y=rect.height-this.elem.offsetHeight;
        }else if(typeof this.parentOut==="object"){
            if(x<0) x=0;
            if(x>=this.parentOut.width-this.elem.offsetWidth)x=this.parentOut.width-this.elem.offsetWidth;
            if(y<0) y=0;
            if(y>=this.parentOut.height-this.elem.offsetHeight) y=this.parentOut.height-this.elem.offsetHeight;
            if(this.parentOut.width===0) x=0;
            if(this.parentOut.height===0) y=0;
        }
        this.elem.style.left=x+"px";
        this.elem.style.top=y+"px";
    }else{
        document.removeEventListener("mousemove",this.obj.mousedownHandler)
        document.removeEventListener("mouseup",this.obj.mousedownHandler)
    }
},

dragOff:function(elem){
    elem.obj=null;
    document.obj=null;
    elem.removeEventListener("mousedown",this.mousedownHandler);
}
```

#### 案例：坐标存储

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="/封装.js"></script>
    <style>
        div {
            width: 25px;
            height: 25px;
            position: absolute;
            background-color: red;
            border:1px solid #000000;
            left:0;
            top:0;
        }
    </style>
</head>
<body>
    <div></div>
    <script>
        var arr=[],//存储轨迹坐标
            record=false, //开始或者结束记录的标志  true 为开始  false为结束
            bool=false;  //标志演示是否开始  true为开始 false 为为开始
        var div;
        init();
        function init(){
            //获取div
            div=document.querySelector("div");
            // 给该div加拖拽事件
            Utils.dragElem(div);
            div.addEventListener("mousedown",mouseHandler);
            document.addEventListener("mouseup",mouseHandler);
            setInterval(animation,16);
        }
        function mouseHandler(e){
            if(e.type==="mousedown"){
                //当鼠标按下的时候开始记录
                record=true;
            }else if(e.type==="mouseup"){
                //当鼠标释放的时候  记录停止，开始演示
                bool=true;
                record=false;
                arr.reverse();
            }
        }
        function animation(){
            recordPath();//记录路径
            elemMove();//轨迹演示
        }
        //记录路径
        function recordPath(){
            //如果record为false 则跳出
            if(!record) return;
            //如果record为true，就记录坐标
            arr.push({x:div.offsetLeft,y:div.offsetTop});
        }
        //轨迹演示
        function elemMove(){
            //如果bool为false  则跳出
            if(!bool) return;
            //如果bool为true，则开始演示
            //首先判断arr内是否有坐标
            //如果没有，则将bool设置为false，然后跳出
            if(arr.length===0){
                bool=false;
                return;
            }
            //取出末尾元素，因为记录的第一个位置在arr头部，所以将arr翻转取元素
            var point=arr.pop();
            //设置div的坐标left和top
            div.style.left=point.x+"px";
            div.style.top=point.y+"px";
        }
    </script>
</body>
</html>
```

#### 案例：右键菜单创建元素

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: none;
      position: absolute;
      z-index: 999;
    }

    li {
      padding: 5px 20px;
      background-color: skyblue;
      user-select: none;
      font-size: 12px;
    }

    li:hover {
      background-color: steelblue;
    }
  </style>
  <script src="/封装.js"></script>
</head>

<body>
  <ul>
    <li>新建</li>
    <li>复制</li>
    <li>剪切</li>
    <li>粘贴</li>
    <li>删除</li>
  </ul>
  <script>
    var ul, //菜单栏外容器
      pre, //指向的是上一个元素
      cloneElem; //要复制的元素
    //将右键内所包含的元素存储在数组中，方便之后调用
    var arr = ["新建", "复制", "剪切", "粘贴", "删除"];
    init();

    function init() {
      ul = document.querySelector("ul");
      //给document添加一个点击事件来处理右键菜单
      document.addEventListener("contextmenu", contextMenu);
      //给ul添加了事件侦听，移出事件和点击事件
      //实际上侦听的是ul中的子元素li，这叫事件委托
      ul.addEventListener("mouseleave", contextMenu);
      ul.addEventListener("click", clickHandler);
    }

    function contextMenu(e) {
      //判断侦听该事件的事件类型是否是contextmenu
      if (e.type === "contextmenu") {
        //如果是，则先阻止右键的默认事件
        e.preventDefault();
        //然后将菜单栏显示，并且设置ul的位置距离
        ul.style.display = "block";
        ul.style.left = e.clientX - 20 + "px";
        ul.style.top = e.clientY - 10 + "px";
      } else {
        //如果不是contextmenu,则就是鼠标移出事件
        //此时将右键菜单栏设置为隐藏
        ul.style.display = "none";
      }
    }

    function clickHandler(e) {
      //如果点击的事件的构造函数不是HTMLLIElemet，就跳出函数
      if (e.target.constructor !== HTMLLIElement) return;
      //如果是，则设置菜单栏为隐藏
      ul.style.display = "none";
      //然后，去寻找点击的内容在arr数组中对应的下标
      switch (arr.indexOf(e.target.textContent)) {
        case 0:
          //如果为0  则是创建
          //传入此时鼠标的位置，执行创建函数
          createElem(e.clientX, e.clientY);
          break;
        case 1:
          //如果为1.则是复制
          //如果此时pre不存在，也就说是第一个元素，则跳出
          if (!pre) return;
          //如果pre存在，则复制该元素
          //cloneNode 传递两个参数  
          //如果为true，则递归复制当前节点所有的子孙节点
          //如果为false  则只复制当前节点
          cloneElem = pre.cloneNode(false);
          break;
        case 3:
          //如果为3，则是粘贴
          //首先判断是否有复制元素
          //如果没，则跳出函数
          if (!cloneElem) return;
          //如果有，则在document中添加复制的元素
          document.body.appendChild(cloneElem);
          //然后给新粘贴的这个元素添加点击事件
          cloneElem.addEventListener("click", selectClickHandler);
          //再给新创建的元素添加一个选中状态
          selectElem(cloneElem);
          //然后设置cloneELem的位置
          //该元素的位置应当就是鼠标点击的位置向左，向上偏移13px
          Object.assign(cloneElem.style, {
            left: e.clientX - 13 + "px",
            top: e.clientY - 13 + "px"
          });
          //粘贴完毕，将复制的对象置为空
          cloneElem = null;
          break;
        case 2:
          //2是剪切
          //如果之前不存在元素，则跳出函数
          if (!pre) return;
          cloneElem = pre.cloneNode(false);
        //因为剪切完毕之后，要进行删除操作
        //为了提高代码的可重用性，剪切完直接穿透使用删除的代码
        case 4:
          //4 为删除
          //首先移除元素的点击事件
          pre.removeEventListener("click", selectClickHandler);
          //清空元素的选中状态
          selectElem(null);
          //然后移除元素，但此时元素依旧在，只是不显示
          pre.remove();
          //将pre设置为null，清除元素的引用状态
          pre = null;
          break;
      }
    }
    //创建元素节点
    function createElem(x, y) {
      //使用封装好的创建元素节点方法创建元素
      //并将样式一个个赋值给该元素
      //第一个参数是要创建的元素
      //第二个参数是设置该元素的style样式
      //第三个参数是要创建元素的父元素

      var div = Utils.ce(
        "div",
        {
          width: "25px",
          height: "25px",
          position: "absolute",
          left: x - 13 + "px",
          top: y - 13 + "px",
          backgroundColor: Utils.randomColor(),
        },
        "body"
      );
      //给新创建好的div添加选中状态
      selectElem(div);
      //并给该元素添加点击事件
      div.addEventListener("click", selectClickHandler);
    }
    //只有点击之后，才会选中元素
    function selectClickHandler(e) {
      selectElem(this);
    }
    //实际上该方法做的是切换状态所用
    function selectElem(elem) {
      //如果之前有元素存在
      //在选中该元素的时候， 将上一个元素的border置为none
      //并且取消上一个元素的拖拽事件
      if (pre) {
        pre.style.border = "none";
        Utils.dragOff(pre);
      }
      //如果找不到当前元素，则跳出函数
      if (!elem) return;
      //如果之前有元素存在，且可以找到当前元素
      pre = elem;
      //那么就给当前元素添加拖拽事件
      Utils.dragElem(pre);
      //并且将当前元素的边框设为2px
      pre.style.border = "2px solid #000000";
    }
  </script>
</body>

</html>
```

#### 案例：人物走路

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        var actor,code;
        var bool=false,
            dic="",
            time=0,
            speed=1,
            num=0,
            x=0,
            y=0;
        
        init();
        function init(){
            actor=createActor();
            document.addEventListener("keydown",keyHandler);
            document.addEventListener("keyup",keyHandler);
            setInterval(animation,16);
        }

        function createActor(){
           var  actor=document.createElement("div");
            Object.assign(actor.style,{
                width:"32px",
                height:"32px",
                position:"absolute",
                left:0,
                top:0,
                backgroundImage:'url(./img/Actor01-Braver03.png)',
            });
            document.body.appendChild(actor);
            return actor;
        }

        // 37,38,39,40（左上右下）
        function keyHandler(e){
           bool=e.type==="keydown";
           code=e.keyCode;
           if(e.type==="keyup"){
               actor.style.backgroundPositionX="0px";
               time=0;
           }
        }

        function animation(){
            if(!bool) return;
       
            actorMove();
            actorAction();
        }

        function actorAction(){
            if(code<37 || code>40) return;
            time--;
            if(time>0)return;
            time=15;
            actor.style.backgroundPositionX=num++%4*-32+"px"
        }

        function actorMove(){
            switch(code){
                case 37:
                if(dic!=="left"){
                    actor.style.backgroundPositionY="-33px";
                    dic="left"
                }
                  x-=speed;
                break;
                case 38:
                if(dic!=="top"){
                    actor.style.backgroundPositionY="-99px";
                    dic="top"
                }
                  y-=speed;
                break;
                case 39:
                if(dic!=="right"){
                    actor.style.backgroundPositionY="-66px";
                    dic="right"
                }
                   x+=speed;
                break;
                case 40:
                if(dic!=="bottom"){
                    actor.style.backgroundPositionY="0px";
                    dic="bottom"
                }
                  y+=speed;
                break;
            }
            actor.style.left=x+"px";
            actor.style.top=y+"px";
        }
    </script>
</body>
</html>
```

## 正则表达式

#### 正则表达式的创建

构造函数创建

```
var reg=new RegExp(正则内容,修饰符);
```

字面量创建

```
var reg=/正则内容/修饰符
```

#### 修饰符

| 修饰符 | 描述         |
| ------ | ------------ |
| i      | 不区分大小写 |
| g      | 全局匹配     |
| m      | 多行匹配     |

#### 正则对象的方法

test()：

​		返回一个布尔值，判断test()参数中的字符串中有没有匹配正则表达式内容，匹配成功返回true，失败返回false

```
var reg=/a/i;
var bool=reg.test("bcdf");
console.log(bool);	//false
```

exec()：

返回一个数组，表示exec()参数中字符串匹配正则的内容

【注】exec()不会全局匹配

```
var reg=/a/ig;
var arr=reg.exec("bcAdfa");
console.log(arr); // [A]
```

字符串的方法：

search()

只能找到第一个不能全局匹配，返回找到内容下标

```
var str="0Babcdef";
var index= str.search(/b/i);
console.log(index);	//1
```

match()

把找到匹配的元素用数组罗列，如果没有全局匹配和exec相同

```
var str="0Babcdef";
var arr=str.match(/b/ig);
console.log(arr);	//[B，b]

var str="catcbtc/tc1tc.tcabt";
console.log(str.match(/cat/g));	//["cat"]
console.log(str.match(/cbt/g));	//["cbt"]
```

replace()

当使用全局匹配时，可以完成所有元素的匹配替换

```
var str="0Babcdef";
str=str.replace(/b/ig,"z");
console.log(str);	//0zazcdef

str=str.replace(/b/ig,function(item,index){
    console.log(item,index);	//找到的元素和下标 B 1  b 3
    if(item==="B") return "Z";
    return "z";
})
console.log(str);	//0Zazcdef
```

split()

```
var str="abc(nihao)dejs";
str=str.split(/[\(\)]/);
console.log(str);	//["abc", "nihao", "dejs"]
```

#### 元字符

字符类-转义字符类

| 元字符 | 描述                                                     |
| ------ | :------------------------------------------------------- |
| .      | 查找单个字符，除了换行和行结束符。                       |
| \w     | 查找单词字符。包括字母、数字和下划线，与[a-zA-Z_0-9]相同 |
| \W     | 查找非单词字符。与**[^0-9A-Za-z_]**相同                  |
| \d     | 查找数字。与[0-9]相同                                    |
| \D     | 查找非数字字符。与**[^0-9]**相同                         |
| \s     | 查找空白字符。                                           |
| \S     | 查找非空白字符。                                         |



| 量词   | 描述                                  |
| ------ | ------------------------------------- |
| n+     | 匹配任何包含至少一个 n 的字符串。     |
| n*     | 匹配任何包含零个或多个 n 的字符串。   |
| n?     | 匹配任何包含零个或一个 n 的字符串。   |
| n{x}   | 匹配包含 X 个 n 的序列的字符串。      |
| n{x,y} | 匹配包含 X 或 Y 个 n 的序列的字符串。 |
| n{x,}  | 匹配包含至少 X 个 n 的序列的字符串。  |
| n$     | 匹配任何结尾为 n 的字符串。           |
| ^n     | 匹配任何开头为 n 的字符串。           |

**.** 匹配任何一个字符 是一个通配符

```
var str="catcbtc/tc1tc.tcabt";

console.log(str.match(/c.t/g)); //["cat","cbt","c/t","c1t","c.t"]
console.log(str.match(/c\.t/g));	//["c.t"]
```

[ab] 表示a或者b任意一个字符
[abcdefghi] 匹配其中任意一个

```
var str="catcbtc/tc1tc.tcabt";

console.log(str.match(/c[abcdefghi]t/g))	//["cat", "cbt"]
console.log(str.match(/c[a-i]t/g))	//["cat", "cbt"]
console.log("catcytcjt".match(/c[a-ik-z]t/g))	//["cat", "cyt"]
```

写在[]中的.就是转义字符.，不是通配符

```
console.log("ab.cd".match(/[ad.]/g));	//["a", ".", "d"]
```

所有的括号必须增加转义\

```
console.log("ab.cd".match(/[\{\}\[\]\(\)]/g));
```

两个\ 在字符或者正则表达式的[]都是一个\

```
console.log("aa\\a\a".match(/[\\]/g));	//["\"]
```

[0-20]  [0-2 0] === [0-2]

```
console.log("ab12nfs2".match(/[0-9]/g));	//["1", "2", "2"]
console.log("134".match(/[0-20]/g));	//["1"]
```

```
console.log("aZsw".match(/[a-zA-Z]/g));
console.log("aZsw".match(/[a-zA-Z0-9]/g));
//错误的,Unicode编码中a比Z大
console.log("aZsw".match(/[a-Z]/g));
//错误大写Z到a中间还有其他字符串
console.log("aZsw".match(/[A-z]/g));
console.log("abcdef".match(/[a-ce-z]/g));
```

[dabaaabcc]  注意这里出现了重复和顺序问题，这种写法其实没有任何意义，与[abcd]相同

在[]内第一个字符是^，表示后面的字符不用，取反

```
console.log("abcdef".match(/[^d]/g));	//["a", "b", "c", "e", "f"]
console.log("abc^def".match(/[^\^]/g));//不要上箭头
```

如果^不是第一个，作为字符^使用

```
console.log("abc^def".match(/[a^c]/g));	//["a", "c", "^"]
```

案例：

```
var str="中国四大古典名著有'西游记','红楼梦','水浒','三国演义'";
// "中国四大古典名著有《西游记》,《红楼梦》,《水浒》,《三国演义》"
// "中国四大古典名著有<西游记>,<红楼梦>,<水浒>,<水浒>";
var n=0;
str=str.replace(/'/g,function(item){
    return n++%2===0 ? "《" : "》";
});
str=str.replace(/[《》]/g,function(item){
    return item==="《" ? "<" : ">";
});
console.log(str);
```

#### 重复

｛n｝这里n是重复的次数，用｛｝表示要重复寻找。如果这个n是0时，例如a{0}匹配任何空字符。

```
console.log("aaaaaa".match(/a{6}/));	//["aaaaaa"]
console.log("aabbaaabbb".match(/a{2}b{2}/g));	//["aabb", "aabb"]
console.log("aaaaaaa".match(/a{2}/g));	//["aa", "aa", "aa"]
console.log("aaaaaaa".match(/a{3}/g));	//["aaa", "aaa"]
console.log("aaaaaaa".match(/a{0}/g)); //["", "", "", "", "", "", "", ""]
```

先匹配最大的字符串  贪婪匹配

```
console.log("aaaaaaa".match(/a{1,4}/g));	//["aaaa", "aaa"]
console.log("aaaaaaa".match(/a{0,3}/g));	//["aaa", "aaa", "a", ""]
console.log("colour".match(/colou{0,1}r/g));	//可以有也可以没有	["colour"]
console.log("color".match(/colou{0,1}r/g));		//["color"]
//{1,} 匹配至少1个也可以多个
console.log("aaaaaaa".match(/a{1,}/g));//{1,}	//["aaaaaaa"]
//{0,} 可以有可以有若干个
console.log("aaaaaaa".match(/a{0,}/g));		//["aaaaaaa", ""]
```

非贪婪匹配。

或者+  或者 ｛num,｝  ? 来匹配最少的部分
中间内容，中间夹得那个取最少

```
console.log('".aa""bbbb""dddd"'.match(/".+?"/));	//[".aa"]
console.log('"...""bbbb""dddd"'.match(/"(.)\1+"/));		// \1+是匹配两个以上 ["..." , .]
```

关于重复的转义字符

```
/a*/g    /a{0,}/g
/a+/g    /a{1,}/g
/a?/g    /a{0,1}/g
```

|	或者

```
console.log("abcd".match(/ab/g));	//ab
console.log("abcd".match(/[ac][bd]/g));		//ab cd
console.log("abcd".match(/ab|cd/g)); 	//找ab或者cd
console.log("abcd".match(/ab||cd/g));	//ab,"","",""
console.log("abcd".match(/ab|cd|/g));	//ab,cd,""
console.log("abcd".match(/|ab|cd/g));	//"","","","",""
```

案例：

```
<div class="div1 div2 div4"></div>

var div = document.querySelector("div");
addClass(div, "div3     div6 div2   ");
removeClass(div, "div3     div6 div2   ");

function addClass(elem, className) {
  var arr1 = elem.className.trim().split(/\s+/);
  var arr2 = className.trim().split(/\s+/);
  console.log(arr1, arr2);
  arr1.forEach(function (item) {
    if (arr2.indexOf(item) < 0) arr2.push(item);
  })
  elem.className = arr2.join(" ");
}

function addClass(elem, className) {
  elem.className = (elem.className.trim() + " " + className.trim())
    .split(/\s+/)
    .reduce(function (value, item) {
      if (value.indexOf(item) < 0) value.push(item);
      return value;
    }, [])
    .join(" ");
}


function removeClass(elem, className) {
  var arr = className.trim().split(/\s+/);
  elem.className = elem.className.trim().split(/\s+/).reduce(function (value, item) {
    if (arr.indexOf(item) < 0) value.push(item);
    return value;
  }, []).join(" ");
}
```

案例：

```
//   ([a-z])\1  相同重复
var str="aaabbffddeeaaggfddssaaggeer".split("").sort()
.join("").match(/(\w)\1*/g).reduce(function(value,item){
    value+=item[0]+"["+item.length+"]";
    return value;
},"")

console.log(str);
```

案例：

```
var str = "<p>Uber的这款无人车原型配备了多个<strong>摄像头</strong>、<em>激光雷达</em>以及<span>传感器</span>，可看清100米范围内任何方向的东西</p><br/><p>第二行内容，哎嘿，第二行内容</p>";
str = str.replace(/<.*?>/g, function (item) {
  if (item === "<br/>") return "\n";
  return "";
});
console.log(str);
```

#### 选择和起始结束

要完成一个全体内容匹配就需要使用起始和结束符来操作

^  起始符，表示开始从这个开始匹配

```
console.log("bbaacc".match(/^a+/g));//要求起始就需要是一个a以上	null
```

$ 结束符，要求必须以某个字符结束

```
 console.log("bbaacc".match(/c+$/g));	//["cc"]
```

案例

```
var user=document.querySelector("#user");
var ids;
user.addEventListener("input",inputHandler);
function inputHandler(e){
    if(ids) return;
    ids=setTimeout(function(){
        clearTimeout(ids);
        ids=undefined;
        regText(user.value);
    },500)
}

function regText(txt){
    var span= user.nextElementSibling;
    if(/^[1-9]$|^[12][0-9]$|^3[01]$/.test(txt)){
        span.textContent="满足1-31";
        span.style.color="green";
    }else{
        span.textContent="不满足1-31";
        span.style.color="red";
    }
}
```

案例

```
<input type="text" name="user" id="user"><span></span><br>
<input type="password" name="password" id="password"><span></span><br>
<input type="text" name="email" id="email"><span></span><br>

var inputs=document.querySelectorAll("input");
init();
function init(){
    inputs.forEach(function(item){
        item.ids=0;
        item.addEventListener("input",inputHandler)
    })
}
function inputHandler(e){
    if(this.ids) return;
    var input=this;
    this.ids=setTimeout(function(){
        clearTimeout(input.ids);
        input.ids=undefined;
        regText(input);
    },500)
}

function regText(input){
    var span= input.nextElementSibling;
    if(regTest(input.value,input.name)){
        span.textContent="OK";
        span.style.color="green";
    }else{
        span.textContent="错误";
        span.style.color="red";
    }
}

function regTest(txt,name){
    switch(name){
        case "user":
        return /^\w{8,36}$/.test(txt);
        case "password":
        return /^(?=\D+\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,16}$/.test(txt);
        case "email":
        return /^\w{3,36}@\w+\.(com|net|cn|org)$/.test(txt);
    }

}
```



#### 群组

- 当使用match时，如果使用群组，加上g和不加g是有差距

  不加g可以将每个群组列表在数组的下标1开始的元素

  加g就不能找到群组内容

```
console.log("aabcddaa".match(/(a+)bc(d+)(a+)/));	//aabcddaa,aa,dd,aa
console.log("10[a]3[bc]".match(/(\d+)\[([a-zA-Z]+)\]/g));	//["10[a]", "3[bc]"]
```

- 在replace中如果不使用群组，后面的函数中参数第一位是符合正则内容，第二位是这个字符的下标

  在replace中如果使用群组，后面的函数中参数分别是符合正则的内容，和每个群组的内容

```
var str="10[a]3[bc]".replace(/(\d+)\[([a-zA-Z]+)\]/g,function(item1,item2,item3){
   return item3.repeat(item2);
});
console.log(str);
```

```
var str="backgroundPositionX".replace(/[A-Z]/g,function(item){
    return "-"+item.toLowerCase()
});
console.log(str);

var str="background-position-x".replace(/-([a-z])/g,function(item,item1){
    return item1.toUpperCase();
});
console.log(str);
```

```
var str="13879061235".replace(/(\d{3})\d{4}(\d{4})/,"$1****$2");
//$1代表第一个群组，$2代表第二个群组
console.log(str);
```

#### 断言

**前瞻断言**

先行断言，紧随其后

查找紧随其后的内容是某个字符的条件

```
console.log("abac".match(/a(?=b)/g));
console.log("abac".replace(/a(?=c)/g,"z"));
```

 查找紧随其后的内容不是某个字符的条件

```
console.log("abac".replace(/a(?!c)/g,"z"));
```

**后瞻断言**

后行断言，紧随其前

前面必须是某个条件，紧随其后的字符

```
console.log("abcb".replace(/(?<=a)b/g,"z"));
console.log("6a66b7d".replace(/(?<=\d+)[a-z]+/g,"z"));
```

前面必须不是某个条件，紧随其后的字符

```
console.log("abcb".replace(/(?<!a)b/g,"z"));
```

```
"a4"
"aaaaaa4"
"aaslkdjaslkj4"
"a"
"As"
"A1232938s"
//字符中必须包含大写、小写字母，也必须包含数字，但是数字不能作为第一位使用
console.log(/^(?=\D+\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{8,16}$/)


// /[\u4e00-\u9fa5]/  匹配中文字符
```

## 动画

- 帧频 	1秒中播放多少帧 
- 帧         1帧就是一张图片播放的时间
- 60帧频        1000/60=16.666666

##### 案例：小球撞壁反弹

###### 面向过程写法

```
var balls;
var ids;

init();
function init(){
    balls=document.querySelectorAll(".ball");
    for(var i=0;i<balls.length;i++){
        balls[i].speedX=Math.floor(Math.random()*5)+1;
        balls[i].speedY=Math.floor(Math.random()*6)+1;
        balls[i].x=Math.floor(Math.random()*700);
        balls[i].y=Math.floor(Math.random()*300);
    }
    animation();
}

function animation(){
    // 开启固定60帧频
   ids=requestAnimationFrame(animation);
//    cancelAnimationFrame(ids);//清除时间帧请求
    for(var i=0;i<balls.length;i++){
        if(balls[i].x+50>800 || balls[i].x<0) balls[i].speedX=-balls[i].speedX;
        if(balls[i].y+50>400 || balls[i].y<0) balls[i].speedY=-balls[i].speedY;
        balls[i].x+=balls[i].speedX;
        balls[i].y+=balls[i].speedY;
        balls[i].style.left=balls[i].x+"px";
        balls[i].style.top=balls[i].y+"px";
    }
}
```

###### 面向对象写法

```
RedBall.js
import Utils from "./Utils.js";

export default class RedBall {
    speedX = 2;
    speedY = 3;
    x = 0;
    y = 0;
    w=50;
    rect;
    constructor() {
        this.elem = this.createElem();
    }
    createElem() {
        if (this.elem) return this.elem;
        this.w = Utils.random(30, 60);
        //给小球随机宽度高度
        let div = Utils.ce("div", {
            width: this.w + "px",
            height: this.w + "px",
            borderRadius: "50%",
            backgroundColor: Utils.randomColor(),
            position: "absolute",
        })
        return div;
    }
    appendTo(parent) {
        if (parent.constructor === String) parent = document.querySelector(parent);
        parent.appendChild(this.elem);
        this.rect=parent.getBoundingClientRect();
        //获取容器的相对于视窗的位置集合
    }
  
    move(x, y) {
        if(x) this.x=x;
        if(y) this.y=y;
        //如果传入参数，则赋值给this.x，如果没有传入参数，则将对象的x赋值
        this.elem.style.left = this.x + "px";
        this.elem.style.top = this.y + "px";
    }
    update() {
        if (this.x + this.w > this.rect.width || this.x < 0) this.speedX = -this.speedX;
        if (this.y + this.w > this.rect.height || this.y < 0) this.speedY = -this.speedY;
        //如果碰到边框，则将速度取反，小球向相反的方法移动
        this.x+=this.speedX;
        this.y+=this.speedY;
        this.move();
    }
    dispose(){
    //清除小球
        this.elem.remove();
        this.elem=null;
    }
}


HTML:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .con
        {
            width:800px;
            height:400px;
            border: 1px solid #000000;
            position: relative;
            margin: auto;
            left: 0;
            right: 0;
        }
    </style>
</head>
<body>
    <div class="con"></div>
    <script type="module">
        import Utils from "./js/Utils.js";
        import RedBall from "./js/RedBall.js";
        var arr=[],time=0;
        init();
        function init(){
            animation();
        }

        function animation(){
            requestAnimationFrame(animation);
            //不用setInterval，用requestAnimationFrame()方法直接执行下一帧
            createBall();
            update();
        }

        function createBall(){
            time--;
            if(time>0) return;
            time=12;
            //用节流，每进来12次，执行一次函数
            if(arr.length>30){
            	//如果小球的个数大于30，调用对象中dispose()方法删除
                arr[0].dispose();
                arr[0]=null;
                arr.shift();
            }
            var b=new RedBall();
            //调用类
            b.speedX=Utils.random(2,6);
            //随机给个速度
            b.speedY=Utils.random(3,8);
            b.move(Utils.random(0,700),Utils.random(0,300));
            //调用对象中move方法，给小球随机的X和Y的初始位置
            b.appendTo(".con");
            //将小球放在div容器中
            arr.push(b);
        }
        function update(){
            arr.forEach(function(item){
                item.update();
            })
        }
    </script>
</body>
</html>
```

##### 案例：加载的动画

```
LoadBall.js
import Utils from "./Utils.js";
export default class LoadBall{
    x=0;
    y=0;
    r=30;
    angle=360;
    constructor(){
        this.elem = this.createElem();
    }
    createElem(){
        if (this.elem) return this.elem;
        let div = Utils.ce("div", {
            width:  "10px",
            height: "10px",
            borderRadius: "50%",
            backgroundColor: "rgba(220,165,60,1)",
            position: "absolute",
        })
        return div;
    }
    changeBg(color){
        this.elem.style.backgroundColor=color;
    }
    appendTo(parent) {
        if (parent.constructor === String) parent = document.querySelector(parent);
        parent.appendChild(this.elem);
        this.rect=parent.getBoundingClientRect();
    }
    move(x,y){
        this.x=x;
        this.y=y;
    }
    alpha(_alpha){
        this.elem.style.opacity=_alpha;
    }
    update(){
        this.angle-=5;
        if(this.angle<=0) this.angle=360;
        this.elem.style.left=this.x+Math.sin(this.angle*Math.PI/180)*this.r+"px";
        this.elem.style.top=this.y+Math.cos(this.angle*Math.PI/180)*this.r+"px";
    }
}


HTML:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script type="module">
        import LoadBall from "./js/LoadBall.js";
        import Utils from "./js/Utils.js";
        var arr=[];
        init();
         function init(){
            var color=Utils.randomColor();
            var x=(document.documentElement.clientWidth-60)/2;
            var y=(document.documentElement.clientHeight-60)/2;
            //让动画居中显示
            for(var i=0;i<20;i++){
            //20个球旋转
                var b=new LoadBall();
                b.angle=i===0 ? 360 : i*15;
                //每个球的初始角度不同
                b.changeBg(color);
                //改变颜色
                b.move(x,y)
                //设置小球的初始位置
                b.alpha(1-i*0.05);
                //设置每个小球的透明度
                b.appendTo("body");
                //将小球加入到body里
                arr.push(b);
            }

            animation();
            
         }

         function animation(){
             requestAnimationFrame(animation);
             arr.forEach(item=>{
                 item.update();
                 //遍历每个小球旋转
             })
         }

    </script>
</body>
</html>
```

##### CSS动画

1、导入animate.css文件

2、`<link *rel*="styleSheet" *href*="css/animate.css">`

3、`<div class="animated fadeOutDownBig">这是一个特效文字</div>`

##### Tween

```
Tween.js
直接下载引入

HTML：
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .div0{
            width:50px;
            height: 50px;
            background-color: red;
            position: absolute;
            border-radius: 50%;
           
        }
        .con
        {
            width: 100%;
            height: 400px;
            position: relative;
            top:30px;
  
        }
    </style>
    <script src="./js/Tween.js"></script>
</head>
<body>
    
    <select id="select0"></select>
    <select id="select1"></select>
    <div class="con">
        <div class="div0"></div>
    </div>
    <script>

        var div0,select0,select1,con;
        init();
        function init(){
            div0=document.querySelector(".div0");
            con=document.querySelector(".con");
            select0=document.querySelector("#select0");
            select1=document.querySelector("#select1");
            for(var prop in TWEEN.Easing){
                var option=document.createElement("option");
                option.textContent=prop;
                select0.appendChild(option);
            }
            con.addEventListener("click",clickHandler);
            select0.addEventListener("change",changeHandler);
            var evt=new Event("change");
            select0.dispatchEvent(evt);
            animation();
        }

        function changeHandler(e){
            var prop=select0.value;
            select1.innerHTML="";
            for(var str in TWEEN.Easing[prop]){
                var option=document.createElement("option");
                option.textContent=str;
                select1.appendChild(option);
            }
        }

        function clickHandler(e){
            // new TWEEN.Tween(初始对象)
            var tween=new TWEEN.Tween({x:div0.offsetLeft,y:div0.offsetTop});
            // tween.to(目标对象,运行时长)
            tween.to({x:e.clientX-25,y:e.clientY-25-30},500);
            // 增加缓动效果
            tween.easing(TWEEN.Easing[select0.value][select1.value])
            // 实时更新执行函数update
            tween.onUpdate(update);
            tween.onComplete(complete);
            tween.repeat(1);//重复
            tween.yoyo(true);//悠悠球效果，必须基于repeat方法
            // 开始缓动
            tween.start();
        }

        function complete(){
            console.log("动画完成");
        }

        function update(){
            // console.log(this);
            div0.style.left=this.x+"px";
            div0.style.top=this.y+"px";
        }

        function animation(){
            requestAnimationFrame(animation);
            TWEEN.update();
        }
    </script>
</body>
</html>
```

